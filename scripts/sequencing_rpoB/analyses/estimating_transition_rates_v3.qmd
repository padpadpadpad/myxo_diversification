---
title: "Estimating ancestral states"
author: "Daniel Padfield"
date: last-modified
format:
  html:
    toc: true
    toc-depth: 2
    toc-title: 'Contents'
    code-overflow: wrap
    code-fold: true
    code-tools: true
    self-contained: true
    self-contained-math: true
    number-sections: true
execute:
  message: false
  warning: false
  fig.align: 'center'
editor: visual
---

## Outline

Using information on the tip states of a phylogenetic tree we can use evolutionary models to estimate the ancestral states of internal nodes and transitions between states.

We fit an $Mk$ model of evolution to our tree and habitat preference data to understand how habitat preference evolved. For example does evolution readily allow transitions between specialist habitat preferences (i.e. from marine mud only to terrestrial only).

We also try and fit an $Mk$ model of evolution when we combine two traits together (habitat preference and whether or not the species has high or low diversification rate as identified by BAMM).

Ancestral state reconstructions can also be estimated from the MuSSE and HiSSE models we are aiming to fit later on. These models would have a lot of free parameters and we are unsure whether they can be fit with the dataset we have. We hope to reduce the number of free parameters in those models by estimating the transition matrix which best fits the data in the $Mk$ model. This would reduce the number of free parameters.

## TL;DR

Go to @sec-best_model for the best $Mk$ model and a discussion of the transition matrix.

## Progress and results

-   Done ancestral state reconstructions using a variety of methods:

    -   **ape::ace()**

    -   **castor::asr_mk_model()**

    -   **diversitree::fit_mk()**

    -   **phytools::make.simmap()**

-   Have written a quick primer to [BayesTraits](https://padpadpadpad.github.io/BayesTraitsAcrAllNodes/) but have not used it on our tree due to the time it takes to run the analysis with a transition matrix where all states are different.

-   Have compared the three standard models of evolution for the transition matrix (equal rates, symmetric rates, and all rates different) using **ape::ace()** and the all-rates different method is best. Then did model simplification to find the best model for the transition matrix.

-   Have plotted the ancestral state reconstructions of a subset of the tree. For the whole tree my computer gave up.

-   Have plotted the transition matrix in multiple ways, see @sec-best-model

## Fitting transition rate models and doing ancestral state reconstructions

We can do ancestral state reconstruction with a couple of different methods in R as well as trying in [BayesTraits](http://www.evolution.reading.ac.uk/BayesTraitsV4.0.0/BayesTraitsV4.0.0.html).

For discrete traits, the most commonly used model for evolution on tree is called the $Mk$ model. $M$ stands for Markov because the modelled process is a continuous-time Markov chain, and $k$ because the model is generalised to include an arbitrary number ($k$) states.

The central attribute of the $Mk$ model is a the transition matrix, $Q$, which gives the instantaneous transition rates between states.

An important distinction in ancestral state reconstruction for discrete characters is joint vs. marginal reconstruction. Joint reconstruction is finding the set of character states at all nodes that maximise the likelihood. Marginal reconstruction is finding the state at the current node that maximises the likelihood integrating over all the other states at all nodes, in proportion to their probability.

We can do both marginal reconstruction using **ape::ace()** and **castor::asr_mk_model()** and joint reconstruction using **ape::ace()**.

An alternative tactic to the one outlined above is to use an MCMC approach to sample character histories from their posterior probability distribution. This is called stochastic character mapping. The model is the same but in this case we get a sample of unambiguous histories for our discrete character's evolution on the tree - rather than a probability distribution for the character at nodes.

Finally we can use BayesTraits to do both maximum likelihood and MCMC approaches. We do not use this approach in this walk-through.

The evolutionary models that are used to reconstruct ancestral states have a transition matrix between discrete states that define the rates of transitions between states on the tree. In most of these models, there are three that are easy to define: **ARD** means all transition rates are different, **SYM** means transitions to and from the same states are the same, and **ER** is an equal rates model where all rates between states are the same. These transition matrices can also be custom made but for now these three seem sensible starting points. Transition matrices also underpin the MuSSE and BiSSE models we are hoping to fit.

## Load in R packages

First we will load in R packages used and the metadata file used and wrangled in a previous walk-through.

We also load in the final phylogenetic tree, the colours used for habitat preferences, and the position of shift nodes.

```{r load_packages}
#| results: false
# load packages
library(here)
library(tidyverse)
library(ggtree)
library(ggnewscale)
library(RColorBrewer)
library(patchwork)
library(phytools)
library(MetBrewer)
library(ggpp)
library(castor)
library(diversitree)
library(tidygraph)
library(igraph)
library(ggraph)
library(GGally)
library(ggrepel)
library(flextable)
library(ggridges)

# set where I am in the project
here::i_am('scripts/sequencing_rpoB/analyses/estimating_transition_rates_v3.qmd')

# read in metadata
d_meta <- read.csv(here('data/sequencing_rpoB/processed/asv_metadata.csv'))

# read in tree
tree <- read.tree(here('data/sequencing_rpoB/bamm/rerooted-pruned-chronopl10.tre'))

# edit tree labels
d_labels <- data.frame(tip_label = tree$tip.label) %>%
  separate(., tip_label, c('part1', 'part2', 'part3'), sep = '_', remove = FALSE) %>%
  unite('tip_label_new', c(part1, part2), sep = '_')

tree$tip.label <- d_labels$tip_label_new

# read in shift nodes
shiftnodes <- readRDS(here('data/sequencing_rpoB/processed/shiftnodes.rds'))

```

## Custom function

We will write a custom function for getting the transition matrix into a format that is easy to plot using **ggplot2**.

```{r custom_function}

# function for getting a data frame from a diversitree object
get_diversitree_df <- function(div_obj, trait_vec, replace_vec){
  
  temp <- tibble(param = names(div_obj$par.full)) %>%
    mutate(state_1_num = as.numeric(substr(param, 2,2)),
         state_2_num = as.numeric(substr(param, 3,3)),
         transition_rate = unlist(div_obj$par.full),
         state_1 = stringi::stri_replace_all_regex(state_1_num, pattern = trait_vec, replacement = replace_vec, vectorize=FALSE),
         state_2 = stringi::stri_replace_all_regex(state_2_num, pattern = trait_vec, replacement = replace_vec, vectorize=FALSE)) %>%
    select(param, state_1, state_2, state_1_num, state_2_num, transition_rate) %>%
    mutate(free_param = ifelse(param %in% names(div_obj$par), 'yes', 'no'),
           num_params = length(div_obj$par))
  
  return(temp)
  
}
```

## Create a master dataframe for the trait states

Different methods for estimating ancestral states take different values for the traits. Some only allow for numeric values, whereas others allow characters. Some do not allow colons in the name, and one ([MBASR](https://github.com/stevenheritage/MBASR) which uses Mr Bayes) needs the first trait value to be 0. To allow for us to semi-easily link across different methods, we will make a data frame of our unique tip states and then turn them into a numeric vector. The ordering is all done alphabetically.

```{r tip_state_dataframe}
d_meta <- tibble(tip_label = tree$tip.label) %>%
  left_join(., d_meta)

# make sure order of habitat preference is the same in the trait vector as the tip labels
sum(d_meta$tip_label == tree$tip.label) == length(tree$tip.label)
# SUCCESS if TRUE

# replace NA of outgroup - make it freshwater:terrestrial - the most common state
# phytools::make.simmap cannot take NAs
hab_pref <- setNames(d_meta$habitat_preference, d_meta$tip_label)
hab_pref[is.na(hab_pref)] <- 'freshwater:terrestrial'

# make habitat preference vector numeric
hab_pref_num <- as.numeric(as.factor(hab_pref)) -1
hab_pref_num <- setNames(hab_pref_num, d_meta$tip_label)
hab_pref_num2 <- hab_pref_num + 1

# coding from numeric to character
coding <- tibble(hab_pref = unname(hab_pref), hab_pref_num = unname(hab_pref_num)) %>%
  distinct() %>%
  mutate(hab_pref2 = gsub(':', '.', hab_pref),
         hab_pref_num2 = hab_pref_num + 1) %>%
  arrange(hab_pref) %>%
  mutate(hab_pref_axis = gsub(':', '/ ', hab_pref),
  hab_pref_axis = gsub('_', ' ', hab_pref_axis),
  # rename the columns for easy naming
  initials = c('F', 'FM', 'FT', 'G', 'M', 'MT', 'T'))

coding
```

This results in a dataframe which allows us to easily link between numeric and character values, and also gives us a vector - of the same length of tips in our tree - which we can use for estimating ancestral states.

## Estimate ancestral states using diversitree::fit_mk()

First lets fit each of the models (ER, SYM, and ARD) using **diversitree::fit_mk()**. We can compare these models using AIC and likelihood ratio tests to see which model fits the tree best.

**diversitree** is good because it makes us implicitly code the transitions we want to set to 0 or make equivalent, which aids our understanding of the models we are trying to fit. Its downside is that it takes numbers only, so we have to back-transform our model estimates into their biologically meaningful trait values.

```{r diversitree_1_load}
#| echo: false

# save out files
mod_er <- readRDS(here('data/sequencing_rpoB/processed/transition_rates/mod_er_mac.rds'))
mod_sym <- readRDS(here('data/sequencing_rpoB/processed/transition_rates/mod_sym_mac.rds'))
mod_ard <- readRDS(here('data/sequencing_rpoB/processed/transition_rates/mod_ard_mac.rds'))

# all of these methods needs a likelihood function, we can build a Mkn model
lik_ard <- make.mkn(tree, hab_pref_num2, k = max(hab_pref_num2))

argnames(lik_ard)

# make symmetric rates model
lik_sym <- constrain(lik_ard, 
                     q12~q21, q13~q31, q14~q41, q15~q51, q16~q61, q17~q71,
                     q23~q32, q24~q42, q25~q52, q26~q62, q27~q72,
                     q34~q43, q35~q53, q36~q63, q37~q73,
                     q45~q54, q46~q64, q47~q74,
                     q56~q65, q57~q75,
                     q67~q76
                     )

argnames(lik_sym)

# make equal rates model
lik_er <- constrain.i(lik_ard, rep('q12', length(argnames(lik_ard))), i.free = 1)

lik_er <- constrain(lik_ard,
                    q13~q12, q14~q12, q15~q12, q16~q12, q17~q12,
                    q21~q12, q23~q12, q24~q12, q25~q12, q26~q12, q27~q12,
                    q31~q12, q32~q12, q34~q12, q35~q12, q36~q12, q37~q12,
                    q41~q12, q42~q12, q43~q12, q45~q12, q46~q12, q47~q12,
                    q51~q12, q52~q12, q53~q12, q54~q12, q56~q12, q57~q12,
                    q61~q12, q62~q12, q63~q12, q64~q12, q65~q12, q67~q12,
                    q71~q12, q72~q12, q73~q12, q74~q12, q75~q12, q76~q12)

argnames(lik_er)

# need to pass start values to it - can grab these from the ape::ace, but we will just pass an average rate to the model
inits_ard <- rep(1, length(argnames(lik_ard)))
inits_sym <- rep(1, length(argnames(lik_sym)))
inits_er <- rep(1, length(argnames(lik_er)))
```

```{r diversitree_1_setup}
#| eval: false

# all of these methods needs a likelihood function, we can build a Mkn model
lik_ard <- make.mkn(tree, hab_pref_num2, k = max(hab_pref_num2))

argnames(lik_ard)

# make symmetric rates model
lik_sym <- constrain(lik_ard, 
                     q12~q21, q13~q31, q14~q41, q15~q51, q16~q61, q17~q71,
                     q23~q32, q24~q42, q25~q52, q26~q62, q27~q72,
                     q34~q43, q35~q53, q36~q63, q37~q73,
                     q45~q54, q46~q64, q47~q74,
                     q56~q65, q57~q75,
                     q67~q76
                     )

argnames(lik_sym)

# make equal rates model
lik_er <- constrain.i(lik_ard, rep('q12', length(argnames(lik_ard))), i.free = 1)

lik_er <- constrain(lik_ard,
                    q13~q12, q14~q12, q15~q12, q16~q12, q17~q12,
                    q21~q12, q23~q12, q24~q12, q25~q12, q26~q12, q27~q12,
                    q31~q12, q32~q12, q34~q12, q35~q12, q36~q12, q37~q12,
                    q41~q12, q42~q12, q43~q12, q45~q12, q46~q12, q47~q12,
                    q51~q12, q52~q12, q53~q12, q54~q12, q56~q12, q57~q12,
                    q61~q12, q62~q12, q63~q12, q64~q12, q65~q12, q67~q12,
                    q71~q12, q72~q12, q73~q12, q74~q12, q75~q12, q76~q12)

argnames(lik_er)

# need to pass start values to it - can grab these from the ape::ace, but we will just pass an average rate to the model
inits_ard <- rep(1, length(argnames(lik_ard)))
inits_sym <- rep(1, length(argnames(lik_sym)))
inits_er <- rep(1, length(argnames(lik_er)))

# find the maximum likelihood estimates of this model
mod_er <- find.mle(lik_er, inits_er, method = 'subplex', control = list(maxit = 50000))
mod_sym <- find.mle(lik_sym, inits_sym, method = 'subplex', control = list(maxit = 50000))
mod_ard <- find.mle(lik_ard, inits_ard, method = 'subplex', control = list(maxit = 50000))

AIC(mod_er)
AIC(mod_sym)
AIC(mod_ard)
```

We can compare model fit using AIC and anovas

```{r diversitree_1_compare}

AIC(mod_sym, mod_ard, mod_er) %>% arrange(AIC)

anova(mod_ard, mod_sym)
anova(mod_ard, mod_er)

```

### Model simplificiation of the ARD model

So the ARD model is the best model by a considerable margin using AIC. We can do model simplification of this model to see what parameters can be removed to further improve the model. First we will just plot the distribution of estimated parameters. As most rates are very small we shall do another histogram filtering out the larger rates.

```{r plot_ard}
#| fig.height: 4
#| fig.width: 10

# look at paraemters
mod_ard$par

# plot of all parameters
p1 <- tibble(rate = mod_ard$par) %>%
  ggplot(., aes(rate)) +
  geom_histogram(fill = 'white', col = 'black') +
  theme_bw()

# plot of constrained x axis (rates <1)
p2 <- tibble(rate = mod_ard$par) %>%
  filter(rate < 1) %>%
  ggplot(., aes(rate)) +
  geom_histogram(fill = 'white', col = 'black') +
  theme_bw()

p1+p2

# sort parameter estimates
mod_ard$par %>% sort()

# get parameters close to 0.
mod_ard$par[mod_ard$par < 1e-03] %>% names(.)

```

We can immediately see there are many parameters that are extremely close to 0. We shall set these to zero and refit the model. This plot identifies a bunch of parameters that are extremely close to 1. By sorting them we can see the split here is from e-06 to e-02.

```{r diversitree_2_load}
#| echo: false

# read in files
mod_custom1 <- readRDS(here('data/sequencing_rpoB/processed/transition_rates/mod_custom1_mac.rds'))

# make custom matrix model
lik_custom1 <- constrain(lik_ard, 
                     q16~0, q26~0, q27~0, q35~0, q36~0, q42~0, q46~0, q47~0, q53~0, q54~0, q63~0, q64~0, q72~0, q74~0)

# make start parameters
inits_custom1 <- rep(1, length(argnames(lik_custom1)))

```

```{r diversitree_2_setup}
#| eval: false

# make custom matrix model
lik_custom1 <- constrain(lik_ard, 
                     q16~0, q26~0, q27~0, q35~0, q36~0, q42~0, q46~0, q47~0, q53~0, q54~0, q63~0, q64~0, q72~0, q74~0)

# make start parameters
inits_custom1 <- rep(1, length(argnames(lik_custom1)))

# run model
mod_custom1 <- find.mle(lik_custom1, inits_custom1, method = 'subplex', control = list(maxit = 50000))


```

We can now do model comparison again.

```{r diversitree_2_compare}
# do AIC comparison
AIC(mod_sym, mod_ard, mod_er, mod_custom1) %>% arrange(AIC)

# anova
anova(mod_ard, mod_custom1)
```

This model is loads better again. We can again look at the distribution of rates to see how they look.

```{r plot_custom1}
# filter for only estimated parameters
mod_custom1$par.full[names(mod_custom1$par.full) %in% argnames(lik_custom1)] 
# plot of all parameters
p1 <- tibble(rate = mod_custom1$par.full[names(mod_custom1$par.full) %in% argnames(lik_custom1)]) %>%
  ggplot(., aes(rate)) +
  geom_histogram(fill = 'white', col = 'black') +
  theme_bw()

# plot of constrained x axis (rates <1)
p2 <- tibble(rate = mod_custom1$par.full[names(mod_custom1$par.full) %in% argnames(lik_custom1)]) %>%
  filter(rate < 1) %>%
  ggplot(., aes(rate)) +
  geom_histogram(fill = 'white', col = 'black') +
  theme_bw()

p1+p2

# sort parameter estimates
mod_custom1$par %>% sort()

```

The lowest rate (q17) is around five times smaller than the other low rates. So we shall remove this rate first and compare models.

```{r diversitree_3_load}
#| echo: false

# read in files
mod_custom2 <- readRDS(here('data/sequencing_rpoB/processed/transition_rates/mod_custom2_mac.rds'))

# make custom matrix model
lik_custom2 <- constrain(lik_ard, 
                     q16~0, q26~0, q27~0, q35~0, q36~0, q42~0, q46~0, q47~0, q53~0, q54~0, q63~0, q64~0, q72~0, q74~0, q17~0)

# make start parameters
inits_custom2 <- rep(1, length(argnames(lik_custom2)))
```

```{r diversitree_3_setup}
#| eval: false

# make custom matrix model
lik_custom2 <- constrain(lik_ard, 
                     q16~0, q26~0, q27~0, q35~0, q36~0, q42~0, q46~0, q47~0, q53~0, q54~0, q63~0, q64~0, q72~0, q74~0, q17~0)

# make start parameters
inits_custom2 <- rep(1, length(argnames(lik_custom2)))

# run model
mod_custom2 <- find.mle(lik_custom2, inits_custom2, method = 'subplex', control = list(maxit = 50000))
```

We can now again do model comparison.

```{r diversitree_3_compare}
# do AIC comparison
AIC(mod_sym, mod_ard, mod_er, mod_custom1, mod_custom2) %>% arrange(AIC)

# anova
anova(mod_custom1, mod_custom2)

# sort parameter estimates
mod_custom2$par %>% sort()
```

This model is once again better. We will do the same procedure to remove the next parameters that are extremely low. We can see that q75 and q71 are both extremely low and similar (difference is \~0.008). We will remove q75 first.

```{r diversitree_4_load}
#| echo: false

# read in files
mod_custom3 <- readRDS(here('data/sequencing_rpoB/processed/transition_rates/mod_custom3_mac.rds'))

# make custom matrix model
lik_custom3 <- constrain(lik_ard, 
                     q16~0, q26~0, q27~0, q35~0, q36~0, q42~0, q46~0, q47~0, q53~0, q54~0, q63~0, q64~0, q72~0, q74~0, q17~0, q75~0)

# make start parameters
inits_custom3 <- rep(1, length(argnames(lik_custom3)))

```

```{r diversitree_4_setup}
#| eval: false

# make custom matrix model
lik_custom3 <- constrain(lik_ard, 
                     q16~0, q26~0, q27~0, q35~0, q36~0, q42~0, q46~0, q47~0, q53~0, q54~0, q63~0, q64~0, q72~0, q74~0, q17~0, q75~0)

# make start parameters
inits_custom3 <- rep(1, length(argnames(lik_custom3)))

# run model
mod_custom3 <- find.mle(lik_custom3, inits_custom3, method = 'subplex', control = list(maxit = 50000))
```

We can now again do model comparison.

```{r diversitree_4_compare}
# do AIC comparison
AIC(mod_sym, mod_ard, mod_er, mod_custom1, mod_custom2, mod_custom3) %>% arrange(AIC)

# anova
anova(mod_custom2, mod_custom3)

# sort parameter estimates
mod_custom3$par %>% sort()
```

This model is once again better. We will do the same procedure to remove the next parameters that are extremely low. We will now remove q71.

```{r diversitree_4_load}
#| echo: false

# read in files
mod_custom4 <- readRDS(here('data/sequencing_rpoB/processed/transition_rates/mod_custom4_mac.rds'))

# make custom matrix model
lik_custom4 <- constrain(lik_ard, 
                     q16~0, q26~0, q27~0, q35~0, q36~0, q42~0, q46~0, q47~0, q53~0, q54~0, q63~0, q64~0, q72~0, q74~0, q17~0, q75~0, q71~0)

# make start parameters
inits_custom4 <- rep(1, length(argnames(lik_custom4)))
```

```{r diversitree_4_setup}
#| eval: false

# make custom matrix model
lik_custom4 <- constrain(lik_ard, 
                     q16~0, q26~0, q27~0, q35~0, q36~0, q42~0, q46~0, q47~0, q53~0, q54~0, q63~0, q64~0, q72~0, q74~0, q17~0, q75~0, q71~0)

# make start parameters
inits_custom4 <- rep(1, length(argnames(lik_custom4)))

# run model
mod_custom4 <- find.mle(lik_custom4, inits_custom4, method = 'subplex', control = list(maxit = 50000))
```

We can now again do model comparison.

```{r diversitree_4_compare}
# do AIC comparison
AIC(mod_sym, mod_ard, mod_er, mod_custom1, mod_custom2, mod_custom3, mod_custom4) %>% arrange(AIC)

# anova
anova(mod_custom3, mod_custom4)

# sort parameter estimates
mod_custom4$par %>% sort()
```

Again the model fits better. q51 and q14 are essentially equivalent, so we will now remove them both at once.

```{r diversitree_5_load}
#| echo: false

# read in files
mod_custom5 <- readRDS(here('data/sequencing_rpoB/processed/transition_rates/mod_custom5_mac.rds'))

# make custom matrix model
lik_custom5 <- constrain(lik_ard, 
                     q16~0, q26~0, q27~0, q35~0, q36~0, q42~0, q46~0, q47~0, q53~0, q54~0, q63~0, q64~0, q72~0, q74~0, q17~0, q75~0, q71~0, q51~0, q14~0)

# make start parameters
inits_custom5 <- rep(1, length(argnames(lik_custom5)))
```

```{r diversitree_5_setup}
#| eval: false

# make custom matrix model
lik_custom5 <- constrain(lik_ard, 
                     q16~0, q26~0, q27~0, q35~0, q36~0, q42~0, q46~0, q47~0, q53~0, q54~0, q63~0, q64~0, q72~0, q74~0, q17~0, q75~0, q71~0, q51~0, q14~0)

# make start parameters
inits_custom5 <- rep(1, length(argnames(lik_custom5)))

# run model
mod_custom5 <- find.mle(lik_custom5, inits_custom5, method = 'subplex', control = list(maxit = 50000))
```

We can now again do model comparison.

```{r diversitree_5_compare}
# do AIC comparison
AIC(mod_sym, mod_ard, mod_er, mod_custom1, mod_custom2, mod_custom3, mod_custom4, mod_custom5) %>% arrange(AIC)

# anova
anova(mod_custom4, mod_custom5)

# sort parameter estimates
mod_custom5$par %>% sort()
```

```{r diversitree_6_load}
#| echo: false

# read in files
mod_custom6 <- readRDS(here('data/sequencing_rpoB/processed/transition_rates/mod_custom6_mac.rds'))

# make custom matrix model
lik_custom6 <- constrain(lik_ard, 
                     q16~0, q26~0, q27~0, q35~0, q36~0, q42~0, q46~0, q47~0, q53~0, q54~0, q63~0, q64~0, q72~0, q74~0, q17~0, q75~0, q71~0, q51~0, q14~0, q52~0)

# make start parameters
inits_custom6 <- rep(1, length(argnames(lik_custom6)))
```

```{r diversitree_6_setup}
#| eval: false

# make custom matrix model
lik_custom6 <- constrain(lik_ard, 
                     q16~0, q26~0, q27~0, q35~0, q36~0, q42~0, q46~0, q47~0, q53~0, q54~0, q63~0, q64~0, q72~0, q74~0, q17~0, q75~0, q71~0, q51~0, q14~0, q52~0)

# make start parameters
inits_custom6 <- rep(1, length(argnames(lik_custom6)))

# run model
mod_custom6 <- find.mle(lik_custom6, inits_custom6, method = 'subplex', control = list(maxit = 50000))
```

We can now again do model comparison.

```{r diversitree_6_compare}
# do AIC comparison
AIC(mod_sym, mod_ard, mod_er, mod_custom1, mod_custom2, mod_custom3, mod_custom4, mod_custom5, mod_custom6) %>% arrange(AIC)

# anova
anova(mod_custom5, mod_custom6)

# sort parameter estimates
mod_custom6$par %>% sort()
```

Weirdly q67 has suddenly become really really small, compared to being 1.83 in the previous model. We can remove it and see how the model does.

```{r diversitree_7_load}
#| echo: false

# read in files
mod_custom7 <- readRDS(here('data/sequencing_rpoB/processed/transition_rates/mod_custom7_mac.rds'))

# make custom matrix model
lik_custom7 <- constrain(lik_ard, 
                     q16~0, q26~0, q27~0, q35~0, q36~0, q42~0, q46~0, q47~0, q53~0, q54~0, q63~0, q64~0, q72~0, q74~0, q17~0, q75~0, q71~0, q51~0, q14~0, q52~0, q67~0)

# make start parameters
inits_custom7 <- rep(1, length(argnames(lik_custom7)))
```

```{r diversitree_7_setup}
#| eval: false

# make custom matrix model
lik_custom7 <- constrain(lik_ard, 
                     q16~0, q26~0, q27~0, q35~0, q36~0, q42~0, q46~0, q47~0, q53~0, q54~0, q63~0, q64~0, q72~0, q74~0, q17~0, q75~0, q71~0, q51~0, q14~0, q52~0, q67~0)

# make start parameters
inits_custom7 <- rep(1, length(argnames(lik_custom7)))

# run model
mod_custom7 <- find.mle(lik_custom7, inits_custom7, method = 'subplex', control = list(maxit = 50000))
```

We can now again do model comparison.

```{r diversitree_7_compare}
# do AIC comparison
AIC(mod_sym, mod_ard, mod_er, mod_custom1, mod_custom2, mod_custom3, mod_custom4, mod_custom5, mod_custom6, mod_custom7) %>% arrange(AIC)

# anova
anova(mod_custom6, mod_custom7)

# sort parameter estimates
mod_custom7$par %>% sort()
```

```{r diversitree_8_load}
#| echo: false

# read in files
mod_custom8 <- readRDS(here('data/sequencing_rpoB/processed/transition_rates/mod_custom8_mac.rds'))

# make custom matrix model
lik_custom8 <- constrain(lik_ard, 
                     q16~0, q26~0, q27~0, q35~0, q36~0, q42~0, q46~0, q47~0, q53~0, q54~0, q63~0, q64~0, q72~0, q74~0, q17~0, q75~0, q71~0, q51~0, q14~0, q52~0, q67~0, q34~0)

# make start parameters
inits_custom8 <- rep(1, length(argnames(lik_custom8)))
```

```{r diversitree_8_setup}
#| eval: false

# make custom matrix model
lik_custom8 <- constrain(lik_ard, 
                     q16~0, q26~0, q27~0, q35~0, q36~0, q42~0, q46~0, q47~0, q53~0, q54~0, q63~0, q64~0, q72~0, q74~0, q17~0, q75~0, q71~0, q51~0, q14~0, q52~0, q67~0, q34~0)

# make start parameters
inits_custom8 <- rep(1, length(argnames(lik_custom8)))

# run model
mod_custom8 <- find.mle(lik_custom8, inits_custom8, method = 'subplex', control = list(maxit = 50000))
```

We can now again do model comparison.

```{r diversitree_8_compare}
# do AIC comparison
AIC(mod_sym, mod_ard, mod_er, mod_custom1, mod_custom2, mod_custom3, mod_custom4, mod_custom5, mod_custom6, mod_custom7, mod_custom8) %>% arrange(AIC)

# anova
anova(mod_custom7, mod_custom8)

# sort parameter estimates
mod_custom8$par %>% sort()
```

This parameter is important in the model. Consequently our best model is **mod_custom7**.

## Plot the best transition matrix

We can plot the transition matrix of the best model.

```{r plot_transition_matrix}
#| fig.height: 6
#| fig.width: 8

diversitree_df <- get_diversitree_df(mod_custom7, coding$hab_pref_num2, coding$hab_pref)

diversitree_df %>%
  left_join(., select(coding, state_1 = hab_pref, state_1_num = hab_pref_num2, state_1_label = hab_pref_axis)) %>%
  left_join(., select(coding, state_2 = hab_pref, state_2_num = hab_pref_num2, state_2_label = hab_pref_axis)) %>%
  mutate(transition_rate = round(transition_rate, 2)) %>%
  ggplot(., aes(forcats::fct_reorder(state_2_label, state_2_num), forcats::fct_reorder(state_1_label, desc(state_1_num)))) +
  geom_tile(aes(alpha = transition_rate, col = free_param), width = 0.9, height = 0.9, size = 1.1) +
  theme_bw(base_size = 14) +
  theme(panel.grid.major = element_blank(),
  legend.position = 'none',
  axis.text.x.top = element_text(angle = 90, vjust = 0.5),
  plot.title.position = "plot") +
  scale_alpha_continuous(range = c(0, 0.6)) +
  geom_text(aes(label = transition_rate), size = MicrobioUoE::pts(10)) +
  scale_x_discrete(position = 'top', labels = scales::label_wrap(13)) +
  scale_y_discrete(position = 'left', labels = scales::label_wrap(13)) +
  labs(y = 'state 1',
  x = 'state 2',
  title = paste('all rates different with', length(mod_custom7$par), 'free parameters', sep = ' ')) +
  coord_fixed() +
  scale_color_manual(values = c('red', 'black'))

ggsave(here('plots/sequencing_rpoB/analyses/transition_matrix_diversitree.png'), last_plot(), height = 6, width = 8)

```

## Run MCMC chain for the best Mk model

We can try and run mcmc on this model.

```{r mcmc_load}
#| echo: false

fit_mcmc3 <- readRDS(here('data/sequencing_rpoB/processed/transition_rates/best_diversitree_mcmc.rds'))
```

```{r mcmc_try}
#| eval: false

# set up initial start values
inits_mcmc <- mod_custom7$par

# set up upper and lower limits - limit the values to be < 10 times the max value
lower_mcmc <- rep(0, length(inits_mcmc))
upper_mcmc <- rep(max(inits_mcmc)*10, length(inits_mcmc))

# run first mcmc to tune w
fit_mcmc <- mcmc(lik_custom7, inits_mcmc, nsteps = 10, w = 0.1, upper = upper_mcmc, lower = lower_mcmc)

# tune w for each parameter
w <- diff(sapply(fit_mcmc[2:(ncol(fit_mcmc)-1)], quantile, c(.05, .95)))

# run second mcmc to tune w
fit_mcmc2 <- mcmc(lik_custom7, inits_mcmc, nsteps=100, w=w, upper = upper_mcmc, lower = lower_mcmc)

# tune w for each parameter
w <- diff(sapply(fit_mcmc2[2:(ncol(fit_mcmc2)-1)], quantile, c(.05, .95)))

# run third mcmc for 1000 iter
fit_mcmc3 <- mcmc(lik_custom7, inits_mcmc, nsteps=1000, w=w, upper = upper_mcmc, lower = lower_mcmc)

```

We can easily plot the distribution of these parameter estimates.

```{r plot_mcmc}
#| fig.height: 6
#| fig.width: 5

# make data long format
d_mcmc <- pivot_longer(fit_mcmc3, names_to = 'param', values_to = 'transition_rate', cols = starts_with('q')) %>%
  left_join(., select(diversitree_df, param, state_1, state_2)) %>%
  left_join(., select(coding, state_1 = hab_pref, state_1_num = hab_pref_num2, state_1_label = initials)) %>%
  left_join(., select(coding, state_2 = hab_pref, state_2_num = hab_pref_num2, state_2_label = initials)) %>%
  mutate(parameter = paste(state_1_label, '->', state_2_label))

# find 95% CIs and bind with ML estimates
d_mcmc_summary <- d_mcmc %>%
  group_by(parameter, state_1, state_2) %>%
  tidybayes::mean_qi(transition_rate) %>%
  left_join(., select(diversitree_df, state_1, state_2, ml_estimate = transition_rate))

# plot ridge plot
ggplot(d_mcmc, aes(transition_rate, forcats::fct_reorder(parameter, transition_rate))) +
  geom_density_ridges() +
  theme_bw(base_size = 14) +
  labs(x = 'transition rate',
       y = 'transition')


```

From this it is really clear that the model does not have a very good idea about the value of two transitions: (1) generalist -\> freshwater and (2) generalist -\> freshwater + terrestrial.

We can take 95% CIs and plot these alongside the maximum likelihood estimates.

```{r}
#| fig.height: 6
#| fig.width: 6

# plot 95% CIs
ggplot(d_mcmc_summary, aes(transition_rate, forcats::fct_reorder(parameter, transition_rate))) +
  geom_linerange(aes(xmin = .lower, xmax = .upper)) +
  geom_point(size = 3) +
  geom_point(aes(x = ml_estimate), size = 3, col = 'red') +
  theme_bw(base_size = 14) +
  labs(x = 'transition rate',
       y = 'transition',
       caption = 'red points are ML estimate\nblack points are MCMC average')


```

So it is abundantly clear that the maximum likelihood model is struggling with some parameters. These are linked to transitions that are not very common. It generally does a much better job when parameters are smaller.

One thing that could be happening is that when one of those transitions is high, the other is lower, we can look at the correlation between generalist -\> freshwater (q41) and generalist -\> freshwater + terrestrial (q43).

```{r}

# look at whether the two crazy estimates correlate with each other.
ggplot(fit_mcmc3, aes(q41, q43)) +
  geom_point() +
  theme_bw()

```

Nope there is no correlation here. The model just does not really have a great idea what the transition rate is for these two.

## Stochastic character mapping with phytools

We can now pass the best matrix onto phytools to do stochastic character mapping.

```{r phytools}

# create transition matrix
num_states <- unique(hab_pref) %>% length()

# we will set up the custom matrix, this has 49 numbers and then we have to set the correct numbers to 0
best_matrix <- matrix(1:num_states^2, nrow=num_states)

# make all diagonal numbers NA
for(i in 1:nrow(best_matrix)){
  best_matrix[i,i] <- 0
}

rownames(best_matrix) <- colnames(best_matrix) <- sort(coding$hab_pref)

# populate matrix with estimated parameters from best diversitree model
best_matrix[best_matrix != 0] <- arrange(diversitree_df, state_2, state_1) %>% pull(transition_rate)

# make diagonal values make things sum to 0
diag(best_matrix) <- -rowSums(best_matrix)

```

Run stochastic character mapping

```{r simmap}
#| eval: false

# do stochastic mapping of character traits using phytools
# feed in the best transition matrix previously found using other methods
simmap_best <- make.simmap(tree, hab_pref, nsim = 1000, Q = best_matrix)

# need to split this result up so that files are less than 50MB for GitHub

# number of splits
n_splits <- 10
# find start of each split
splits <- seq(from = 1, to = 1000, by = 1000/10)

# save files out
for(i in 1:length(splits)){
  # save out every 100 sims
  saveRDS(simmap_best[splits[i]:(splits[i]+99)], here(paste("data/sequencing_rpoB/processed/transition_rates/simmap/simmap_", i, '.rds', sep = '')))
}

```

We can then re-load the stochastic character maps in.

```{r load_simmap}
# reload simmap files in
simmap_files <- list.files(here("data/sequencing_rpoB/processed/transition_rates/simmap"), full.names = TRUE)

simmap_best <- purrr::map(simmap_files, readRDS)

simmap_best <- do.call(c, simmap_best)

# load in summary as well!
simmap_summary <- readRDS(here('data/sequencing_rpoB/processed/transition_rates/simmap/simmap_summary.rds'))
```

We can then summarise the stochastic character maps.

```{r summarise_phytools}
#| eval: false

# summarise number of switches between states and time spent in each state
simmap_summary <- describe.simmap(simmap_best, plot=FALSE)

# remove the tree element - this is the simmap_best
simmap_summary$tree <- NULL
```

We can now visualise the results. First we can look at the most common transitions.

```{r simmap_summary}
#| fig-height: 8
#| fig-width: 10

# coerce transitions into dataframe
d_transitions <- as.data.frame(simmap_summary$count, col.names = colnames(simmap_summary$count)) %>%
  mutate(iter = 1:n()) %>%
  pivot_longer(cols = c(everything(), -N, -iter), names_to = 'transition', values_to = 'n_transitions') %>%
  separate(transition, c('state_1', 'state_2'), sep = ',', remove = FALSE) %>%
  mutate(label = gsub(',', ' -> ', transition))

# plot these
group_by(d_transitions, transition) %>%
  filter(max(n_transitions) > 0) %>%
  mutate(average = mean(n_transitions)) %>%
  ungroup() %>%
  mutate(label = fct_reorder(label, desc(average))) %>%
  ggplot() +
  geom_histogram(aes(n_transitions), fill = 'white', col = 'black', binwidth = function(x) (max(x)-min(x))/nclass.FD(x)) +
  facet_wrap(~ label, scales = 'free_x') +
  theme_bw() +
  labs(title = 'Distribution of number of transitions between states',
  subtitle = 'Facets are ordered by common transitions',
  x = 'Number of transitions',
  y = 'Count')
```

We can look at how common transitions are by plotting the averages in a table.

```{r common_transitions}

d_transitions_summary <- group_by(d_transitions, iter) %>%
  mutate(prop = n_transitions/sum(n_transitions)) %>%
  group_by(state_1, state_2) %>%
  summarise(ave_num = mean(n_transitions),
            ave_prop = mean(prop),
            lower_ci = quantile(prop, 0.025),
            upper_ci = quantile(prop, 0.975),
            .groups = 'drop') %>%
  arrange(desc(ave_prop)) %>%
  filter(ave_num > 0)

table <- select(d_transitions_summary, state_1, state_2, ave_num, ave_prop) %>%
  mutate(across(starts_with('state'), function(x) gsub('mud_and_shore', 'marine mud', x)),
         across(starts_with('state'), function(x) gsub(':', ' + ', x)),
         ave_prop = round(ave_prop, 2),
         ave_num = round(ave_num, 0))

table_flex <- flextable(table) %>%
  set_header_labels(state_1 = 'from',
                    state_2 = 'to',
                    ave_prop = 'proportion of all transitions',
                    ave_num = 'number of transitions') %>%
  align(align = 'center', part = 'header') %>%
  bold(part = 'header') %>%
  font(fontname = 'Times', part = 'all') %>%
  fontsize(size = 12, part = 'all') %>%
  autofit()

# save out
save_as_image(table_flex, here('plots/sequencing_rpoB/analyses/proportion_of_transitions.png'), zoom = 3, webshot = 'webshot2')

table_flex
```

## Plot best transition matrix

We can then plot the best model as a network. The output from the stochastic character mapping also contains information as to the time spent in each state in the phylogenetic tree.

```{r plot_best_model}
#| fig-height: 6
#| fig-width: 8

# coerce time into dataframe
d_time <- as.data.frame(simmap_summary$times, col.names = colnames(simmap_summary$times)) %>%
  mutate(n = 1:n()) %>%
  select(-total) %>%
  pivot_longer(cols = c(everything(), -n), names_to = 'state', values_to = 'time') %>%
  group_by(n) %>%
  mutate(prop = time/sum(time)) %>%
  ungroup()

# set colours
cols_hab <- met.brewer('Austria', n = 7)
names(cols_hab) <- c('mud_and_shore', 'freshwater', 'terrestrial', 'freshwater:terrestrial', 'generalist', 'mud_and_shore:terrestrial', 'freshwater:mud_and_shore')
hab_labels <- c('marine mud', 'freshwater', 'terrestrial', 'freshwater + terrestrial', 'generalist', 'marine mud + terrestrial', 'freshwater + marine mud')

# calculate mean time spent in each state
d_timespent <- group_by(d_time, state) %>%
  summarise(mean = mean(prop), .groups = 'drop')

# turn transition matrix into network to plot
d_network <- as_tbl_graph(select(diversitree_df, state_1, state_2, transition_rate)) %>%
  activate(edges) %>%
  filter(!is.na(transition_rate) & transition_rate > 0) %>%
  activate(nodes) %>%
  left_join(., select(d_timespent, name = state, mean)) %>%
  mutate(label = gsub(':', '/', name),
  label = gsub('_', ' ', label),
  label = gsub('mud and shore', 'marine mud', label),
  order = c(1, 2, 6, 7, 3, 4, 5),
  hab1 = gsub(':.*.', '', name),
  hab2 = gsub('.*:', '', name)) %>%
  arrange(order)

p <- ggraph(d_network, layout = 'linear', circular = TRUE) + 
  geom_edge_fan(aes(alpha = transition_rate, 
                width = transition_rate),
                arrow = arrow(length = unit(4, 'mm')),
                end_cap = circle(10, 'mm'),
                start_cap = circle(10, 'mm')) + 
  geom_node_point(aes(size = mean,
                col = name)) +
  theme_void() +
  #geom_node_label(aes(label = label, x=xmin), repel = TRUE) +
  scale_size(range = c(2,20)) +
  scale_edge_width(range = c(0.5, 2)) +
  scale_color_manual('Habitat preference', values = cols_hab, labels = c('terrestrial', 'freshwater', 'marine mud', 'generalist')) +
scale_fill_manual('Habitat preference', values = cols_hab, labels = c('terrestrial', 'freshwater', 'marine mud', 'generalist'))

# grab data for points
point_data <- p$data %>%
  select(x, y, label) %>%
  mutate(nudge_x = ifelse(x < 0, -0.5, 0.5),
  nudge_y = ifelse(y < 0, -0.3, 0.3),
  label = gsub('/', '/\n', label))

p + geom_label(aes(nudge_x + x, nudge_y+y, label = label), point_data, size = MicrobioUoE::pts(18)) +
  theme(legend.position = 'none',
  panel.background = element_rect(fill = 'white', colour = 'white')) +
  coord_cartesian(clip = "off") +
  xlim(c(min(point_data$x) + min(point_data$nudge_x) - 0.3), max(point_data$x) + max(point_data$nudge_x) + 0.3) +
  ylim(c(min(point_data$y) + min(point_data$nudge_y) - 0.1), max(point_data$y) + max(point_data$nudge_y) + 0.1)

# save out model
ggsave(here('plots/sequencing_rpoB/analyses/transition_plot_diversitree.png'), last_plot(), height = 6, width = 8)

```

## Useful links used

-   [Chapter 13](https://lukejharmon.github.io/pcm/chapter13_chardiv/#ref-Beaulieu2016-ww) of Luke Harmon's book on phylogenetic comparative methods on "Characters and diversification rates".
-   [Tutorial](https://www.zoology.ubc.ca/prog/diversitree/doc/diversitree-tutorial.pdf) on using the R package **diversitree**.
-   [Documentation](https://yulab-smu.top/treedata-book/) of the R package **ggtree** used for plotting phylogenies.
-   [Phylo-wiki](https://www.r-phylo.org/wiki/HowTo/Ancestral_State_Reconstruction) help page on ancestral state reconstruction.
-   [Github Issue](https://github.com/YuLab-SMU/ggtree/issues/419#issuecomment-877563385) on plotting pie charts for ancestral state reconstructions.
